import sys
import os
from os import listdir
from os.path import isfile, join, split
import json
import array
import random
import hashlib

import lief

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))


class ModifyBinary():
    def __init__(self, bytez):
        self.bytez = bytez
        self.trusted_path = 'data/trusted/'
        self.good_str_path = 'data/good_strings/'

    def _randomly_select_trusted_file(self):
        return random.choice([join(self.trusted_path, f)
            for f in listdir(self.trusted_path)
                if isfile(join(self.trusted_path, f))])
    
    def _randomly_select_good_strings(self):
        good_strings = random.choice([join(self.good_str_path, f)
            for f in listdir(self.good_str_path)
                if isfile(join(self.good_str_path, f))])
        
        with open(good_strings,'r') as f:
            strings = f.read()
        
        return strings

    def _random_length(self):
        return 2**random.randint(5, 8)

    def _binary_to_bytez(self, binary, imports=False):
        # Write modified binary to disk
        builder = lief.PE.Builder(binary)
        builder.build_imports(imports)
        builder.build()

        self.bytez = array.array('B', builder.get_build()).tobytes()
        return self.bytez

    def rename_section(self):
        binary = lief.PE.parse(list(self.bytez))
        targeted_section = random.choice(binary.sections)
        targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:5]

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def append_random_bytes_to_section(self):
        binary = lief.PE.parse(list(self.bytez))

        # Add part of benign binary to a section
        random_selected_section = random.choice(binary.sections)
        available_size = random_selected_section.size - len(random_selected_section.content)

        upper = random.randrange(256)
        add_bytes = [random.randint(0, upper) for _ in range(available_size)]
        random_selected_section.content = random_selected_section.content + add_bytes
        self.bytez = self._binary_to_bytez(binary)

        return self.bytez


    def modify_machine_type(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.header.machine = lief.PE.MACHINE_TYPES.AMD64
        self.bytez = self._binary_to_bytez(binary)

        return self.bytez

    def add_assorted_bytes_overlay(self):
        upper = random.randrange(256)
        length = self._random_length()
        overlay = bytes([random.randint(0, upper) for _ in range(length)])
        self.bytez += overlay

        return self.bytez
    
    def add_same_bytes_overlay(self):
        byte_pattern = random.choice([0, 169])
        overlay = bytearray([byte_pattern] * 10000)
        self.bytez += overlay

        return self.bytez
    
    def add_benign_data_overlay(self):
        benign_binary = lief.parse(self._randomly_select_trusted_file())
        benign_binary_section_content = benign_binary.get_section('.data').content
        overlay = bytearray(benign_binary_section_content)
        self.bytez += overlay

        return self.bytez
    
    def add_strings(self):
        # open a txt file of strings from low scoring binaries
        good_strings = self._randomly_select_good_strings()
        self.bytez += bytes(good_strings, encoding='ascii')

        return self.bytez

    def add_imports(self):
        # add (unused) imports
        binary = lief.PE.parse(list(self.bytez))

        # draw a library at random
        libname = random.choice(list(COMMON_IMPORTS.keys()))
        funcname = random.choice(list(COMMON_IMPORTS[libname]))
        lowerlibname = libname.lower()

        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == lowerlibname:
                lib = im
                break

        if lib is None:
            # add a new library
            lib = binary.add_library(libname)

        # get current names
        names = set([e.name for e in lib.entries])
        if not funcname in names:
            lib.add_entry(funcname)

        self.bytez = self._binary_to_bytez(binary, imports=True)

        return self.bytez

    def remove_debug(self):
        binary = lief.PE.parse(list(self.bytez))

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    e.rva = 0
                    e.size = 0
                    self.bytez = self._binary_to_bytez(binary)
                    return self.bytez
        # no debug found
        return self.bytez

    def modify_optional_header_linker(self):
        binary = lief.PE.parse(list(self.bytez))

        os = {
            "major_linker_version": [2,6,7,9,11,14],
            "minor_linker_version": [0,16,20,22,25]
        }

        key = random.choice(list(os.keys()))

        if key == 'major_linker_version':
            current_val = binary.optional_header.major_linker_version
            modified_val = random.choice(os[key])
            binary.optional_header.major_linker_version = modified_val
        elif key == 'minor_image_version':
            current_val = binary.optional_header.minor_linker_version
            modified_val = random.choice(os[key])
            binary.optional_header.minor_linker_version = modified_val

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def modify_optional_header_os(self):
        binary = lief.PE.parse(list(self.bytez))
        os = {
            "major_operating_system_version": [4,5,6,10],
            "minor_operating_system_version": [0,1,3]
        }

        key = random.choice(list(os.keys()))

        if key == 'major_operating_system_version':
            current_val = binary.optional_header.major_operating_system_version
            modified_val = random.choice(os[key])
            binary.optional_header.major_operating_system_version = modified_val
        elif key == 'minor_operating_system_version':
            current_val = binary.optional_header.minor_operating_system_version
            modified_val = random.choice(os[key])
            binary.optional_header.minor_operating_system_version = modified_val

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def modify_optional_header_image(self):
        binary = lief.PE.parse(list(self.bytez))

        os = {
            "major_image_version": [0,1,5,6,10],
            "minor_image_version": [0,1,3]
        }

        key = random.choice(list(os.keys()))

        if key == 'major_image_version':
            current_val = binary.optional_header.major_image_version
            modified_val = random.choice(os[key])
            binary.optional_header.major_image_version = modified_val
        elif key == 'minor_image_version':
            current_val = binary.optional_header.minor_image_version
            modified_val = random.choice(os[key])
            binary.optional_header.minor_image_version = modified_val

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

def modify_sample(bytez, action):
    m = hashlib.sha256()
    m.update(bytez)
    print("orig hash: {}".format(m.hexdigest()))
    
    action_func = ACTION_TABLE[action]
    bytez = ModifyBinary(bytez).__getattribute__(action)()
    m = hashlib.sha256()
    m.update(bytez)
    print("new hash: {}".format(m.hexdigest()))

    return bytez


ACTION_TABLE = {
    'append_random_bytes_to_section': 'append_random_bytes_to_section',
    'modify_machine_type': 'modify_machine_type',
    'add_assorted_bytes_overlay': 'add_assorted_bytes_overlay',
    'add_same_bytes_overlay': 'add_same_bytes_overlay',
    'add_benign_data_overlay': 'add_benign_data_overlay',
    'add_strings': 'add_strings',
    'add_imports': 'add_imports',
    'rename_section': 'rename_section',
    'remove_debug': 'remove_debug',
    'modify_optional_header_os': 'modify_optional_header_os',
    'modify_optional_header_image': 'modify_optional_header_image',
    'modify_optional_header_linker': 'modify_optional_header_linker'
}

if __name__ == "__main__":
    import modifier
    # import interface
    from IPython import embed

    with open('../utils/samples/0001ca3c9807665eea81c222485210699bedd08f730f3560c220cb4b749d0c63','rb') as f:
        bytez = f.read()
    
    # action = random.choice(list(ACTION_TABLE.keys()))
    action = 'modify_optional_header_linker'
    print("Action:", action)
    bytez = modify_sample(bytez, action)
    embed()