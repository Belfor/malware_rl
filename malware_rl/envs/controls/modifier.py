import sys
import os
from os import listdir
from os.path import isfile, join, split
import json
import array
import random

import lief

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))


class ModifyBinary():
    def __init__(self, bytez):
        self.bytez = bytez
        self.trusted_path = 'data/trusted/'
        self.good_str_path = 'data/good_strings/'

    def _randomly_select_trusted_file(self):
        return random.choice([join(self.trusted_path, f)
            for f in listdir(self.trusted_path)
                if isfile(join(self.trusted_path, f))])
    
    def _randomly_select_good_strings(self):
        good_strings = random.choice([join(self.good_str_path, f)
            for f in listdir(self.good_str_path)
                if isfile(join(self.good_str_path, f))])
        
        with open(good_strings,'r') as f:
            strings = f.read()
        
        return strings

    def _random_length(self):
        return 2**random.randint(5, 8)
    
    def _search_cave(self, name, body, file_offset, vaddr, cave_size=128, _bytes=b"\x00"):
        found_caves = []
        null_count = 0
        size = len(body)

        for offset in range(size):
            byte = body[offset]
            check = False

            if byte in _bytes:
                null_count += 1
            else:
                check = True

            if offset == size - 1:
                check = True
                offset += 1

            if check:
                if null_count >= cave_size:
                    cave_start = file_offset + offset - null_count
                    cave_end = file_offset + offset
                    cave_size = null_count
                    found_caves.append([cave_start, cave_end, cave_size])
                null_count = 0
        return found_caves

    def _binary_to_bytez(self, binary, imports=False):
        # Write modified binary to disk
        builder = lief.PE.Builder(binary)
        builder.build_imports(imports)
        builder.build()

        self.bytez = array.array('B', builder.get_build()).tobytes()
        return self.bytez

    def rename_section(self):
        binary = lief.PE.parse(list(self.bytez))
        targeted_section = random.choice(binary.sections)
        targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:5]

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def append_random_bytes_to_section(self):
        binary = lief.PE.parse(list(self.bytez))

        # Add part of benign binary to a section
        random_selected_section = random.choice(binary.sections)
        available_size = random_selected_section.size - len(random_selected_section.content)

        upper = random.randrange(256)
        add_bytes = [random.randint(0, upper) for _ in range(available_size)]
        random_selected_section.content = random_selected_section.content + add_bytes
        self.bytez = self._binary_to_bytez(binary)

        return self.bytez

    def inject_bytes_into_cave(self):
        caves = []
        binary = lief.PE.parse(list(self.bytez))
        base_addr = binary.optional_header.imagebase
        for section in binary.sections:
            section_offset = section.pointerto_raw_data
            vaddr = section.virtual_address + base_addr
            infos = list(section.characteristics_lists)
            body = section.content

            if section.sizeof_raw_data > section.virtual_size:
                body.extend(list(b"\x00" * (section.sizeof_raw_data - section.virtual_size)))

            caves.extend(self._search_cave(section.name, body, section_offset, vaddr))

        if caves:
            random_selected_cave = random.choice(caves)
            upper = random.randrange(256)
            add_bytes = bytearray([random.randint(0, upper) for _ in range(random_selected_cave[-1])])
            self.bytez = self.bytez[:random_selected_cave[0]] + add_bytes + self.bytez[random_selected_cave[1]:]

        return self.bytez

    def modify_machine_type(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.header.machine = lief.PE.MACHINE_TYPES.AMD64
        self.bytez = self._binary_to_bytez(binary)

        return self.bytez

    def add_assorted_bytes_overlay(self):
        upper = random.randrange(256)
        length = self._random_length()
        overlay = bytes([random.randint(0, upper) for _ in range(length)])
        self.bytez += overlay

        return self.bytez
    
    def add_same_bytes_overlay(self):
        byte_pattern = random.choice([0, 169])
        overlay = bytearray([byte_pattern] * 10000)
        self.bytez += overlay

        return self.bytez
    
    def add_benign_data_overlay(self):
        random_benign_file = self._randomly_select_trusted_file()
        benign_binary = lief.parse(random_benign_file)

        benign_binary_section_content = benign_binary.get_section('.data').content
        overlay = bytearray(benign_binary_section_content)
        self.bytez += overlay

        return self.bytez
    
    def add_strings(self):
        """
        Open a txt file of strings from low scoring binaries.
        https://skylightcyber.com/2019/07/18/cylance-i-kill-you/
        """
        good_strings = self._randomly_select_good_strings()
        self.bytez += bytes(good_strings, encoding='ascii')

        return self.bytez

    def add_imports(self):
        # add (unused) imports
        binary = lief.PE.parse(list(self.bytez))

        # draw a library at random
        libname = random.choice(list(COMMON_IMPORTS.keys()))
        funcname = random.choice(list(COMMON_IMPORTS[libname]))
        lowerlibname = libname.lower()

        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == lowerlibname:
                lib = im
                break

        if lib is None:
            # add a new library
            lib = binary.add_library(libname)

        # get current names
        names = set([e.name for e in lib.entries])
        if not funcname in names:
            lib.add_entry(funcname)

        self.bytez = self._binary_to_bytez(binary, imports=True)

        return self.bytez

    def remove_debug(self):
        binary = lief.PE.parse(list(self.bytez))

        if binary.has_debug:
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    e.rva = 0
                    e.size = 0
                    self.bytez = self._binary_to_bytez(binary)
                    return self.bytez
        # no debug found
        return self.bytez

    def modify_optional_header(self):
        binary = lief.PE.parse(list(self.bytez))

        oh = {
            "major_linker_version": [2,6,7,9,11,14],
            "minor_linker_version": [0,16,20,22,25],
            "major_operating_system_version": [4,5,6,10],
            "minor_operating_system_version": [0,1,3],
            "major_image_version": [0,1,5,6,10],
            "minor_image_version": [0,1,3]
        }

        key = random.choice(list(oh.keys()))

        modified_val = random.choice(oh[key])
        binary.optional_header.__setattr__(key, modified_val)

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def break_optional_header_checksum(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.optional_header.checksum = 0
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

def modify_sample(bytez, action):
    action_func = ACTION_TABLE[action]
    bytez = ModifyBinary(bytez).__getattribute__(action)()

    return bytez


ACTION_TABLE = {
    'append_random_bytes_to_section': 'append_random_bytes_to_section',
    'modify_machine_type': 'modify_machine_type',
    'add_assorted_bytes_overlay': 'add_assorted_bytes_overlay',
    'add_same_bytes_overlay': 'add_same_bytes_overlay',
    'add_benign_data_overlay': 'add_benign_data_overlay',
    'inject_bytes_into_cave': 'inject_bytes_into_cave',
    'add_strings': 'add_strings',
    'add_imports': 'add_imports',
    'rename_section': 'rename_section',
    'remove_debug': 'remove_debug',
    'modify_optional_header': 'modify_optional_header',
    'break_optional_header_checksum': 'break_optional_header_checksum'
}

if __name__ == "__main__":
    import hashlib
    import modifier
    from IPython import embed

    with open('../utils/samples/0001ca3c9807665eea81c222485210699bedd08f730f3560c220cb4b749d0c63','rb') as f:
        bytez = f.read()

    m = hashlib.sha256()
    m.update(bytez)
    print("original hash: {}".format(m.hexdigest()))
    # action = random.choice(list(ACTION_TABLE.keys()))
    # print("Action:", action)
    action = 'modify_optional_header'
    bytez = modify_sample(bytez, action)
    m = hashlib.sha256()
    m.update(bytez)
    print("modified hash: {}".format(m.hexdigest()))
    embed()